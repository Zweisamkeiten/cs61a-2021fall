---
date created: 2022-10-05 12:10
date updated: 2022-10-05 12:13
---

## 常用表达

正则表达式是一种描述符合特定条件的字符串集的方法，对于模式匹配非常有用。

最简单的正则表达式是匹配一系列字符的正则表达式，例如 `aardvark`匹配字符串中的任何“土豚”子字符串。

但是，您通常希望寻找更有趣的模式。 我们建议使用 [regexr.com 之](https://regexr.com/) 类的在线工具来尝试模式，因为您将获得有关匹配结果的即时反馈。

### 字符类

字符类可以搜索一组字符中的任何一个。 您可以指定集合或使用预定义集合。

| 类        | 描述                             |
| -------- | ------------------------------ |
| `[abc]`  | 匹配 a、b 或 c                     |
| `[a-z]`  | 匹配 a 和 z 之间的任何字符               |
| `[^A-Z]` | 匹配任何不在 A 和 Z 之间的字符。            |
| `\w`     | 匹配任何“单词”字符。 相当于 `[A-Za-z0-9_]` |
| `\d`     | 匹配任何数字。 相当于 `[0-9]`.           |
| `[0-9]`  | 匹配 0 - 9 范围内的单个数字。等价于 `\d`     |
| `\s`     | 匹配任何空白字符（空格、制表符、换行符）。          |
| `.`      | 匹配除换行符以外的任何字符。                 |

可以组合字符类，例如 `[a-zA-Z0-9]`.

### 组合模式

有多种方法可以在正则表达式中将模式组合在一起。

| 组合     | 描述                                                  |
| ------ | --------------------------------------------------- |
| `AB`   | A 的匹配项紧跟 B 的匹配项。示例： `x[.,]y`匹配 "xy" 或 "x,y"         |
| `A\|B` | 匹配 A 或 B。示例： `\d+\|Inf`匹配包含 1 个或多个数字 **或** “Inf”的序列 |

一个模式后面可以跟这些量词之一，以指定可以出现多少个模式实例。

| 量词      | 描述                                                                                  |                |
| ------- | ----------------------------------------------------------------------------------- | -------------- |
| `*`     | 0 次或多次出现前面的模式。 例子： `[a-z]*`匹配任何小写字母序列或空字符串。                                         |                |
| `+`     | 前面的模式出现 1 次或多次。 例子： `\d+`匹配任何非空的数字序列。                                               |                |
| `?`     | 0 或 1 次出现前面的模式。 例子： `[-+]?`匹配可选符号。                                                  |                |
| `{1,3}` | 匹配前面模式的指定数量。 {1,3} 将匹配 1 到 3 个实例。 {3} 将精确匹配 3 个实例。 {3,} 将匹配 3 个或更多实例。 例子： `\d{5,6}` | 匹配 5 位或 6 位数字。 |

### Group

括号的使用与算术表达式类似，用于创建组。 例如， `(Mahna)+`匹配具有 1 个或多个“Mahna”的字符串，例如“MahnaMahna”。 没有括号， `Mahna+`将匹配带有 "Mahn" 后跟 1 个或多个 "a" 字符的字符串，例如 "Mahnaaaa"。

### 锚点

- `^`
  - 匹配字符串的开头。 例子： `^(I|You)`匹配字符串开头的 I 或 You。
- `$`
  - 通常匹配字符串末尾的空字符串或字符串末尾的换行符之前。 例子： `(\.edu|\.org|\.com)$`匹配字符串末尾的 .edu、.org 或 .com。
- `\b`
  - 匹配“单词边界”，即单词的开头或结尾。 例子： `s\b`匹配单词末尾的 s 个字符。

### 特殊字符

上面使用了以下特殊字符来表示模式的类型：

`\ ( ) [ ] { } + * ? | $ ^ .`

这意味着如果您真的想匹配其中一个字符，则必须 _。_ 使用反斜杠对其进行转义 例如， `\(1\+3\)`匹配“(1 + 3)”。

### 在 Python 中使用正则表达式

许多编程语言都有用于将字符串与正则表达式匹配的内置函数。 我们将使用 61A 中的 [Python re 模块]，但您也可以在 SQL、JavaScript、Excel、shell 脚本等中使用类似的功能。

search 方法搜索字符串中任意位置的模式：

`re.search(r"(Mahna)+", "Mahna Mahna Ba Dee Bedebe")`

该方法返回一个匹配对象，该对象在 Python 中被认为是真值，可以检查以找到匹配的字符串。

更多详细信息，请查阅 [re 模块文档](https://docs.python.org/3/library/re.html) 或 [re 教程](https://docs.python.org/3/howto/regex.html) 。

## BNF

Backus-Naur Form (BNF) 是一种用于描述 [上下文无关文法的语法](https://en.wikipedia.org/wiki/Context-free_grammar) 。 它是为描述编程语言的语法而发明的，并且仍然常用于文档和语言解析器。 EBNF 是 BNF 的一种方言，其中包含一些方便的速记。

EBNF 文法包含符号和一组递归产生式规则。 在 61A 中，我们使用 Python Lark 库来编写 EBNF 语法，其中有一些特定的语法编写规则。

有两种类型的符号： 非终结符可以扩展为非终结符（包括它们自己）或终结符。 在 Python Lark 库中，非终结符总是小写的。 终端符号可以是字符串或正则表达式。 在 Lark 中，终端总是大写的。

考虑以下两个生产规则：

```
numbers: INTEGER | numbers "," INTEGER
INTEGER: /-?\d+/
```

符号 `numbers`是具有递归生产规则的非终结符。 它对应于任一 `INTEGER`终端或到 `numbers`符号（本身）加上一个逗号加上一个 `INTEGER`终端。 这 `INTEGER`终端是使用正则表达式定义的，该表达式匹配任意数量的数字，前面带有可选的 - 符号。

该语法可以描述如下字符串：

```
10
10,-11
10,-11,12
```

依此类推，前面有任意数量的整数。

语法还应该指定一个起始符号，它对应于被解析的整个表达式（或整个句子，对于口语）。

对于逗号分隔数字的简单示例，开始符号可能只是数字终端本身：

```
?start: numbers
numbers: numbers "," INTEGER | INTEGER
INTEGER: /-?\d+/
```

EBNF 语法可以使用这些简写符号来指定要匹配的符号数量：

| EBNF 表示法     | 意义      | 纯 BNF 等价                |
| ------------ | ------- | ----------------------- |
| item*        | 零个或多个项目 | items：| items item      |
| item+        | 一项或多项   | items：item | items item |
| [item] item？ | 可选项目    | opitem：| item           |

Lark 还包括一些方便的功能：

- 您可以使用语法底部的忽略指令指定要完成忽略的标记。 例如， `%ignore /\s+/`忽略所有空格（制表符/空格/新行）。
- 您可以为要匹配的常见数据类型导入预定义的终端。 例如，%import common.NUMBER 导入与任何整数或十进制数匹配的终端。

使用所有这些，这是一个对应于计算器语言的 EBNF 语法：

```
start: calc_expr?
calc_expr: NUMBER | calc_op
calc_op: "(" OPERATOR calc_expr* ")"
OPERATOR: "+" | "-" | "*" | "/"

%ignore /\s+/
%import common.NUMBER
```

您可以将其粘贴到 code.cs61a.org，然后在解释器中输入 Calculator 表达式以查看它们的解析树。 试试看！
